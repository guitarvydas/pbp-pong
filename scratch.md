Aside: Unit testing is a well-known concept, but it is more challenging when code is tightly coupled and strongly type-checked at compile time. The PBP approach aims to keep the transport layer simple, allowing for easy assembly and disassembly and replacement of components. This is inspired by the electronics approach, where each software unit is analogous to an integrated circuit, completely isolated and not inherently coupled to any other circuit. The challenge with electronics is the lack of recursion in component design. We desire to build small boards (“shields” in Arduino terminology, “hats” in RPi terminology) and connect them to our system. We want to build up “hats” by connecting other “hats” in a hierarchical manner. Shells, such as `/bin/*sh`, already perform this function by allowing scripts to invoke other scripts. However, the sequential and textual nature of shell scripts makes it difficult to express and explore non-sequential problem domains.

Perhaps this suggests that PBP is merely a method for experimenting with ideas and constructing test jigs, but the concept of divide-and-conquer extends far beyond that. By breaking down a design, it becomes easier to bench-test and implement a production version. This approach also frees developers from the need to perform all type-checking at compile time, facilitating experimentation and design refinement. Consequently, the possibility of later optimizing the design for production remains open. Today, developers write code while simultaneously optimizing the design, which can slow down the process and encourage premature design decisions. This often leads to customers providing free feedback and Q&A, which can be considered a negative cost since they are paying for the privilege of using under-designed products.