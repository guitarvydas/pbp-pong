<!DOCTYPE html>
<html>
<head>
  <title>Test GUI</title>
  <style>
    body { 
      margin: 20px; 
      font-family: monospace;
      background: #808080;
      color: #d4d4d4;
    }
    #canvas { 
      border: 2px solid #4ec9b0; 
      background: #000;
      display: block;
      margin: 20px 0;
    }
    #log {
      background: #252526;
      padding: 10px;
      height: 200px;
      overflow-y: auto;
      border: 1px solid #3e3e42;
    }
    .log-entry {
      margin: 2px 0;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h2>Test GUI - Slave Display</h2>
  <canvas id="canvas"></canvas>
  <div id="log"></div>

  <script>
    // Will be initialized from daemon
    let DEFAULTS = null;
    
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const logDiv = document.getElementById('log');
    
    // Display state
    let objects = {};
    
    // Render throttling
    let renderScheduled = false;
    
    function log(msg) {
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
    }
    
    function render() {
      if (!DEFAULTS) return; // Wait for initialization
      
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw all objects
      for (const [id, obj] of Object.entries(objects)) {
        if (obj.type === 'ball') {
          ctx.fillStyle = obj.color || DEFAULTS.ball.color;
          ctx.beginPath();
          ctx.arc(
            obj.x, 
            obj.y, 
            obj.radius !== undefined ? obj.radius : DEFAULTS.ball.radius,
            0, 
            Math.PI * 2
          );
          ctx.fill();
        } else if (obj.type === 'paddle') {
          ctx.fillStyle = obj.color || DEFAULTS.paddle.color;
          ctx.fillRect(
            obj.x, 
            obj.y, 
            obj.width !== undefined ? obj.width : DEFAULTS.paddle.width,
            obj.height !== undefined ? obj.height : DEFAULTS.paddle.height
          );
        }
      }
    }
    
    // Handle queries and return responses
    function handleQuery(msg) {
      const response = { id: msg.id };
      
      switch (msg.query) {
        case 'objects':
          response.result = objects;
          break;
        
        default:
          response.error = `Unknown query: ${msg.query}`;
      }
      
      return response;
    }
    
    // Connect to daemon
    const ws = new WebSocket('ws://localhost:8080');
    
    ws.onopen = () => {
      log('Connected to daemon');
    };
    
    ws.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        log (event.data);

        // Handle initialization from daemon
        if (data.type === 'init' && data.defaults) {
          DEFAULTS = data.defaults;
          canvas.width = DEFAULTS.canvas.width;
          canvas.height = DEFAULTS.canvas.height;
          log(`Initialized with canvas size: ${DEFAULTS.canvas.width}x${DEFAULTS.canvas.height}`);
          render();
          return;
        }
        
        // Check if this is a query
        if (data.query) {
          const response = handleQuery(data);
          ws.send(JSON.stringify(response));
          return;
        }
        
        // Handle both single object and array of objects
        const commands = Array.isArray(data) ? data : [data];
        
        for (const cmd of commands) {
          const id = cmd.id || cmd.type;
          objects[id] = { ...objects[id], ...cmd };
        }
        
        // Schedule render (throttled to browser refresh rate)
        if (!renderScheduled) {
          renderScheduled = true;
          requestAnimationFrame(() => {
            render();
            renderScheduled = false;
          });
        }
      } catch (e) {
        log(`Error parsing message: ${e.message}`);
      }
    };
    
    ws.onclose = () => {
      log('Disconnected from daemon');
    };
    
    ws.onerror = (error) => {
      log(`WebSocket error: ${error.message}`);
    };
  </script>
</body>
</html>
